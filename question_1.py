# -*- coding: utf-8 -*-
"""Question 1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SDq4D2DdW1u6WrG4Da5GmdaT_gErTol_

**Question 1**
Implement Inverse CDF sampling for the Fréchet distribution. With sufficient number of samples, plot the kernel density estimation plot and show that you are able to match the PDF
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import gaussian_kde

def frechet_icdf(u, alpha, s):
    return s * (-np.log(u)) ** (-1/np.reshape(alpha, (1, -1)))

def frechet_pdf(x, alpha, s):
    if x <= 0:
        return 0
    else:
        return (alpha/s) * (x/s) ** (-alpha-1) * np.exp(-(x/s) ** (-alpha))

# Parameters
alpha = 2
s = 1

# Generate random samples
n_samples = 100000
u = np.random.uniform(size=n_samples)
x = frechet_icdf(u, alpha, s)

# Plot the KDE plot
x_grid = np.linspace(0, 10, 1000)
pdf_values = np.array([frechet_pdf(xi, alpha, s) for xi in x_grid])
kde = gaussian_kde(x)
kde_values = kde(x_grid)
plt.plot(x_grid, pdf_values, label='PDF')
plt.plot(x_grid, kde_values, label='KDE')
plt.legend()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import gaussian_kde

def frechet_icdf(u, alpha, s):
    return np.reshape(s, (-1, 1)) * (-np.log(u)) ** (-1/np.reshape(alpha, (-1, 1)))

def frechet_pdf(x, alpha, s):
    if x <= 0:
        return 0
    else:
        return (alpha/s) * (x/s) ** (-alpha-1) * np.exp(-(x/s) ** (-alpha))

# Parameters
alpha = 2
s = [1,2,3,4,5]

# Generate random samples
n_samples = 100000
u = np.random.uniform(size=n_samples)
x = frechet_icdf(u, alpha, s)

# Plot the KDE plot
x_grid = np.linspace(0, 10, 1000)
pdf_values = np.array([frechet_pdf(xi, alpha, s[0]) for xi in x_grid])
kde = gaussian_kde(x.flatten())
kde_values = kde(x_grid)
plt.plot(x_grid, pdf_values, label='PDF')
plt.plot(x_grid, kde_values, label='KDE')
plt.legend()
plt.show()

# Define parameters
alpha_1 = 1.0
beta_1 = 1.0
alpha_2 = 2.0
beta_2 = 1.0
alpha_3 = 5.0
beta_3 = 1.0

# Define Fréchet distribution PDFs
def frechet_pdf_1(x):
    if x <= 0:
        return 0
    else:
        return (alpha_1 / beta_1) * ((x / beta_1) ** (-alpha_1 - 1)) * np.exp(-((x / beta_1) ** -alpha_1))

def frechet_pdf_2(x):
    if x <= 0:
        return 0
    else:
        return (alpha_2 / beta_2) * ((x / beta_2) ** (-alpha_2 - 1)) * np.exp(-((x / beta_2) ** -alpha_2))

def frechet_pdf_3(x):
    if x <= 0:
        return 0
    else:
        return (alpha_3 / beta_3) * ((x / beta_3) ** (-alpha_3 - 1)) * np.exp(-((x / beta_3) ** -alpha_3))

# Generate samples using inverse CDF sampling

import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import norm, kde

# Fréchet distribution parameters
alpha = 3
s = 1

# Inverse CDF function
def inverse_cdf(u, alpha, s):
    return s * (-np.log(u))**(-1/alpha)

# Number of samples
n_samples = 100000

# Generate samples using inverse CDF sampling
u = np.random.uniform(size=n_samples)
x = inverse_cdf(u, alpha, s)

# Plot kernel density estimation and PDF
fig, ax = plt.subplots()
x_axis = np.linspace(0, 6, 1000)
ax.plot(x_axis, alpha/s * (x_axis/s)**(-alpha-1) * np.exp(-(x_axis/s)**(-alpha)), label='PDF')
density = kde.gaussian_kde(x)
ax.plot(x_axis, density(x_axis), label='Kernel density estimation')
ax.legend()

# Plot histogram with 50 bins
fig, ax = plt.subplots()
ax.hist(x, bins=50, density=True)

# Plot empirical CDF
fig, ax = plt.subplots()
ax.hist(x, bins=100, density=True, cumulative=True, histtype='step', label='Empirical CDF')
ax.plot(x_axis, norm.cdf(x_axis, loc=np.mean(x), scale=np.std(x)), label='Standard Normal CDF')
ax.legend()
plt.show()